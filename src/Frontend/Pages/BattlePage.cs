using SmashUp.Backend.GameObjects;
using SmashUp.Backend.Models;
using SmashUp.Frontend.Pages.Target;
using SmashUp.Frontend.Utilities;
using System;
using System.Text;


internal class Option
{
    public Guid Id { get; }
    public string Text { get; }

    public Option(string text, Guid? id=null)
    {
        Id = id ?? Guid.NewGuid();
        Text = text;
    }
}

namespace SmashUp.Frontend.Pages
{
    /// <summary>
    /// Handles rendering the Battle page
    /// Almost all rendering is static, based on what is passed in
    /// EXCEPT the input field, which changes which displayables 
    /// are displayed based on  what the targeter is actually targeting
    /// </summary>
    internal class BattlePage(List<BaseSlot> baseSlots, Player activePlayer, List<Displayable> inputField, List<Option> buttons, Targeter targeter, string displayText = "") : ValuePage<Guid>
    {
        private readonly Targeter _targeter = targeter;
        private readonly List<BaseSlot> _baseSlots = baseSlots;
        private readonly Player _activePlayer = activePlayer;
        private readonly List<Displayable> _inputField = inputField;
        private int _optionDisplayIndex = 0;
        private readonly List<Option> _buttons = buttons;

        //Eventually I want the InputField to be generated by generic blocks rather than hardcoded options
        //This way we can display anything we could want down there
        private readonly string _displayText = displayText;

        // STATIC VARIABLES
        readonly int CARD_FIELD_SIZE = 15;

        protected override StringBuilder GenerateRender(int consoleWidth, int consoleHeight)
        {
            int baseFieldPadding = 1;
            int statFieldPadding = 1;
            int otherRenderGraphicsLength = 1;

            //Initalize vars and generate fields
            StringBuilder? renderBuffer = null;
            var baseField = GenerateBaseField(consoleWidth - 1);
            var consoleField = GenerateInputField(consoleWidth - 1);
            var statField = GenerateStatField();


            //Ensure the current console size will fit the header
            int renderWidth = new[] {
                baseField.Length > 0 ? baseField.Max(line => line.Length) : 0,
                statField.Max(line => line.Length),
                consoleField.Length > 0 ? consoleField.Max(line => line.Length) : 0
            }.Max();

            var buttonField = GenerateButtonField(renderWidth);

            int renderHeight = baseField.Length +
                               baseFieldPadding +
                               statField.Length +
                               statFieldPadding +
                               consoleField.Length +
                               buttonField.Length +
                               otherRenderGraphicsLength;

            //Make sure the whole render can fit in the console
            if (consoleHeight - 1 >= renderHeight && consoleWidth - 1 >= renderWidth)
            {
                //Generate final combined render
                string[] render = new string[renderHeight];
                int i = 0;
                foreach (string line in baseField)
                {
                    render[i++] = line;
                }
                i += baseFieldPadding;

                //Separation Graphic
                StringBuilder lineBuilder = new();
                lineBuilder.Append('─', renderWidth);
                render[i++] = lineBuilder.ToString();

                foreach (string line in statField)
                {
                    render[i++] = line;
                }
                i += statFieldPadding;
                foreach (string line in consoleField)
                {
                    render[i++] = line;
                }
                foreach (string line in buttonField)
                {
                    render[i++] = line;
                }

                renderBuffer = RenderUtil.Center(render, (consoleHeight - 1, consoleWidth - 1));
            }
            //Let the user know the screen is too small
            if (renderBuffer is null)
            {
                string[] render =
                [
                    $@"Please increase your screen size"
                ];
                renderBuffer = RenderUtil.Center(render, (consoleHeight - 1, consoleWidth - 1));
            }

            return renderBuffer;
        }

        /// <summary>
        /// Generates the base graphics
        /// </summary>
        private string[] GenerateBaseField(int fieldWidth)
        {
            List<BaseCard> activeBases = _baseSlots.Select(x => x.BaseCard).ToList();

            // Get Active Bases Graphics
            string[][] activeBasesGraphics = activeBases
                .Select(GenerateCardGraphic)
                .ToArray();

            // Get Attached Cards Graphics
            string[][] attachedCardGraphics = _baseSlots
                .Select(GetBaseAttachmentGraphics)
                .ToArray();

            if (activeBasesGraphics.Length != attachedCardGraphics.Length) throw new Exception($"Recieved {activeBasesGraphics.Length} active bases but only {attachedCardGraphics.Length} attached card graphics. They should be equal");

            // Calculate array size
            int baseGraphicHeight = activeBasesGraphics.Length > 0 ? activeBasesGraphics.Max(baseGraphic => baseGraphic.Length) : 0;
            int paddingHeight = 1;
            int numCardFieldLines = Math.Max(attachedCardGraphics.Length > 0 ? attachedCardGraphics.Max(x => x.Length) : 0, CARD_FIELD_SIZE);
            var baseField = new string[baseGraphicHeight + paddingHeight + numCardFieldLines];

            // Calculate padding
            int baseGraphicWidth = activeBasesGraphics.Length > 0 ? activeBasesGraphics.Max(baseGraphic => baseGraphic.Max(line => line.Length)) : 0;
            int horizontalPaddingLength = (fieldWidth - (baseGraphicWidth * activeBases.Count)) / (activeBases.Count + 1);

            // Generate combined graphics
            for (int i = 0; i < baseField.Length; i++)
            {
                StringBuilder lineBuilder = new();

                for (int j = 0; j < activeBases.Count; j++)
                {
                    if (i < activeBasesGraphics[j].Length)
                    {
                        //Adding this line will make the bases centered, rather than left justified
                        //if(j == 0) lineBuilder.Append(' ', horizontalPaddingLength);

                        lineBuilder.Append(activeBasesGraphics[j][i]);

                        if (j < activeBases.Count - 1 && horizontalPaddingLength > 0)
                            lineBuilder.Append(' ', horizontalPaddingLength);
                    }
                    else if (i < activeBasesGraphics[j].Length + paddingHeight)
                    {
                        lineBuilder.Append(string.Empty);
                    }
                    else
                    {
                        int attachedCardIndex = i - (baseGraphicHeight + paddingHeight);
                        int currBaseArea = activeBasesGraphics[j].Max(x => x.Length) + horizontalPaddingLength;

                        string currString = attachedCardIndex < attachedCardGraphics[j].Length
                            ? attachedCardGraphics[j][attachedCardIndex]
                            : string.Empty;

                        lineBuilder.Append(RenderUtil.LeftJustifyString(currString, currBaseArea));
                    }
                }

                baseField[i] = lineBuilder.ToString();
            }

            return baseField;
        }
        /// <summary>
        /// Generates the field that lists the game statistics
        /// </summary>
        private string[] GenerateStatField()
        {
            //These are all the elements of the stat field
            List<string> statFieldElements =
            [
                $"{_activePlayer.Name}'s Turn",
                $"Minion Plays: {_activePlayer.MinionPlays}",
                $"Action Plays: {_activePlayer.ActionPlays}",
                $"VP: {_activePlayer.VictoryPoints}"
            ];

            //Join elements and padding
            string elementSeparator = $" | ";
            string paddedStatField = string.Join(elementSeparator, statFieldElements);

            //Return as array
            return [paddedStatField];
        }
        /// <summary>
        /// Generates the field that displays the result of user input. Usually will be their hand, but is also how they view their decks
        /// </summary>
        private string[] GenerateInputField(int fieldWidth)
        {
            string[][] CardGraphicsToDisplay = [];

            // Hand/Option Display
            if (_inputField.Count > 0)
            {
                string[][] allGraphics = _inputField
                    .Select(card =>
                    {
                        return card switch
                        {
                            PlayableCard playable => GenerateCardGraphic(playable),
                            BaseCard baseCard => GenerateCardGraphic(baseCard),
                            Displayable display => GenerateDisplayGraphic(display)
                        };
                    })
                    .ToArray();

                int longestGraphicLength = allGraphics.Max(graphic => graphic.Max(line => line.Length));
                int numToDisplay = Math.Min(fieldWidth / (longestGraphicLength + 1), _inputField.Count);

                // Update option display index if the targeter is targeting a card one outside of our view
                // Ex. Move to other part of hand
                _optionDisplayIndex = Math.Min(_optionDisplayIndex, _inputField.Count - numToDisplay);
                if (_optionDisplayIndex + numToDisplay < _inputField.Count && _targeter.GetTargetId() == _inputField[_optionDisplayIndex + numToDisplay].Id)
                {
                    _optionDisplayIndex++;
                }
                else if (_optionDisplayIndex > 0 && _targeter.GetTargetId() == _inputField[_optionDisplayIndex - 1].Id)
                {
                    _optionDisplayIndex--;
                }

                CardGraphicsToDisplay = allGraphics[_optionDisplayIndex..(numToDisplay + _optionDisplayIndex)];
            }

            int cardHeight = CardGraphicsToDisplay.Length > 0 ? CardGraphicsToDisplay.Max(graphic => graphic.Length) : 0;
            string[] inputField = new string[cardHeight + 2];

            //Display Text Field
            inputField[0] = _displayText;
            inputField[1] = "";

            for (int i = 0; i < cardHeight; i++)
            {
                StringBuilder lineBuilder = new();

                for (int j = 0; j < CardGraphicsToDisplay.Length; j++)
                {
                    lineBuilder.Append(CardGraphicsToDisplay[j][i]);
                    if (j < CardGraphicsToDisplay.Length - 1) lineBuilder.Append(' ');
                }

                inputField[i + 2] = lineBuilder.ToString();
            }

            return inputField;
        }
        /// <summary>
        /// Generates the end turn button
        /// </summary>
        /// <returns></returns>
        private string[] GenerateButtonField(int lineWidth)
        {
            if (_buttons.Count == 0) return [];
            int paddingLength = (int)Math.Floor(((double)lineWidth - _buttons.Sum(x => x.Text.Length + 4)) / (_buttons.Count + 1));
            string padding = new(' ', paddingLength);

            List<string[]> buttonGraphics = [];
            foreach (var button in _buttons)
            {
                buttonGraphics.Add(CreateButtonGraphic(button));
            }

            string[] buttonField = new string[3];
            for (int i = 0; i < 3; i++)
            {
                buttonField[i] = $"{padding}{string.Join(padding, buttonGraphics.Select(x => x[i]).ToList())}{padding}";
            }

            return buttonField;
        }
        public override Guid? HandleKeyPress(UserKeyPress keyPress)
        {
            return _targeter.HandleKeyPress(keyPress);
        }

        private string[] GenerateCardGraphic(PlayableCard card)
        {
            return CardGraphicUtil.GeneratePlayableCardGraphic(card.Graphic, card.Name, card.CurrentPower, card.Id == _targeter.GetTargetId());
        }
        private string[] GenerateCardGraphic(BaseCard baseCard)
        {
            bool isHighlighted = baseCard.Id == _targeter.GetTargetId();
            return CardGraphicUtil.GenerateBaseCardGraphic(baseCard.Graphic, baseCard.Name, baseCard.CurrentPower, baseCard.CurrentBreakpoint, isHighlighted);
        }
        private string[] GenerateDisplayGraphic(Displayable display)
        {
            bool isHighlighted = display.Id == _targeter.GetTargetId();
            return CardGraphicUtil.GenerateDisplayGraphic(display.Graphic, isHighlighted);
        }
        private string[] GetBaseAttachmentGraphics(BaseSlot baseSlot)
        {
            return CardGraphicUtil.GetAttachedCardsGraphic(baseSlot, _targeter.GetTargetId());
        }
        private string[] CreateButtonGraphic(Option button)
        {
            bool isTargeted = _targeter.GetTargetId() == button.Id;
            int textLength = button.Text.Length;

            return [
                isTargeted ? $"╔═{new string('═', textLength)}═╗" : $"┌─{new string('─', textLength)}─┐",
                isTargeted ? $"║ {button.Text} ║" : $"│ {button.Text} │",
                isTargeted ? $"╚═{new string('═', textLength)}═╝" : $"└─{new string('─', textLength)}─┘",
            ];
        }
    }
}
